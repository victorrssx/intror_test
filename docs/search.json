[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R e RStudio para Iniciantes",
    "section": "",
    "text": "1 Objects\n[…]",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Objects</span>"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "R e RStudio para Iniciantes",
    "section": "",
    "text": "Se o número de horas que a pessoa descansou for maior do que 8, então a variável deverá apresentar valor igual a TRUE – ou seja, é verdade que a pessoa dormiu mais de 8 horas. Caso contrário, FALSE.↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Objects</span>"
    ]
  },
  {
    "objectID": "prim-passos.html",
    "href": "prim-passos.html",
    "title": "2  Primeiros passos",
    "section": "",
    "text": "2.1 Operadores Aritméticos\nDe agora em diante, cada região sombreada de cinza representa código, ao passo que seu resultado estará exposto logo na sequência. Vamos começar com um exemplo simples:\n1 + 1\n\n[1] 2\nNesse caso, o nosso comando foi o código 1 + 1 e a saída foi o valor 2. Como você pode reproduzir esse comando no RStudio? Inicialmente, copie o que está escrito acima ao clicar no símbolo de prancheta no canto superior direito da região sombreada. Na sequência, cole no Editor de Código e aperte Ctrl + Enter (ou então no Console, pressionando apenas Enter). Observe abaixo!\nTente agora jogar no Console a expressão: 2 * 2 - (4 + 4) / 2. Deu zero? Pronto! Você já é capaz de pedir ao R para fazer qualquer uma das quatro operações aritméticas básicas. Repare que as operações e suas precedências são mantidas como na matemática, ou seja, divisão e multiplicação são calculadas antes da adição e subtração, além de os parênteses ditarem a ordem na qual serão realizadas. A seguir, apresentamos a Tabela 2.1 resumindo como fazer as principais operações no R.\nTabela 2.1: Operadores matemáticos do R\n\n\n\n\n\n\nOperação\nOperador\nExemplo\nResultado\n\n\n\n\nAdição\n+\n1 + 1\n2.00\n\n\nSubtração\n-\n4 - 2\n2.00\n\n\nMultiplicação\n*\n2 * 3\n6.00\n\n\nDivisão\n/\n5 / 3\n1.67\n\n\nPotenciação\n^\n4 ^ 2\n16.00\n\n\nResto da Divisão\n%%\n5 %% 3\n2.00\n\n\nParte Inteira da Divisão\n%/%\n5 %/% 3\n1.00",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeiros passos</span>"
    ]
  },
  {
    "objectID": "prim-passos.html#operadores-lógicos",
    "href": "prim-passos.html#operadores-lógicos",
    "title": "2  Primeiros passos",
    "section": "2.2 Operadores Lógicos",
    "text": "2.2 Operadores Lógicos\nO R permite também testar comparações lógicas. Os valores lógicos básicos em R são TRUE (ou apenas T) e FALSE (ou apenas F). Por exemplo, podemos pedir ao R que nos diga se é verdadeiro que 5 é menor do que 3. Como a resposta é obviamente negativa, ele retornará FALSE, nos dizendo que a proposição que fizemos é falsa.\n\n5 &lt; 3\n\n[1] FALSE\n\n\nAbaixo, introduzimos a Tabela 2.2 com outros operadores lógicos da linguagem.\n\n\n\n\nTabela 2.2: Operadores lógicos do R\n\n\n\n\n\n\n\n\n\n\n\n\nOperação\nOperador\nExemplo\nResultado\n\n\n\n\nMaior que\n&gt;\n2 &gt; 1\nTRUE\n\n\nMaior ou igual que\n&gt;=\n2 &gt;= 2\nTRUE\n\n\nMenor que\n&lt;\n2 &lt; 3\nTRUE\n\n\nMenor ou igual que\n&lt;=\n5 =&lt; 3\nFALSE\n\n\nIgual à\n==\n4 == 4\nTRUE\n\n\nDiferente de\n!=\n5 != 3\nTRUE\n\n\nx e y\n&\nx &lt;- c(1, 4, NA, 8)  x[!is.na(x) & x &gt; 5]\n8\n\n\nx ou y\n|\nx &lt;- c(1, 4, NA, 8)  x[!is.na(x) | x &gt; 5]\n1, 4, 8",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeiros passos</span>"
    ]
  },
  {
    "objectID": "prim-passos.html#possíveis-complicações",
    "href": "prim-passos.html#possíveis-complicações",
    "title": "2  Primeiros passos",
    "section": "2.3 Possíveis complicações",
    "text": "2.3 Possíveis complicações\nSe você digitar um comando incompleto, como 5 +, e apertar Enter, o R mostrará um +, o que não tem nada a ver com a adição da matemática. Isso significa que o R está esperando você enviar mais algum código para completar o seu comando. Termine o seu comando ou aperte Esc para recomeçar.\n\n5 -\n+ \n+ 5\n\n[1] 0\n\n\nSe você digitar um comando que o R não reconhece, ele retornará uma mensagem de erro. Não entre em pânico. Ele só está te avisando que não conseguiu interpretar o comando.\n\n5 % 2\n\nError: &lt;text&gt;:1:3: unexpected input\n1: 5 % 2\n      ^\n\n\nVocê pode digitar outro comando normalmente em seguida.\n\n5 ^ 2\n\n[1] 25",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeiros passos</span>"
    ]
  },
  {
    "objectID": "funcoes-e-pacotes.html",
    "href": "funcoes-e-pacotes.html",
    "title": "3  Funções e pacotes",
    "section": "",
    "text": "3.1 O que é uma função?\nAntes, vamos pensar em funções no contexto matemático. Segundo Stewart (2015),\nEm que o conjunto \\(A\\) chamamos de domínio, compreendendo todos os valores que a função pode aceitar, ao passo que o conjunto \\(B\\) é conhecido como imagem, compreendendo todos valores que a função consegue retornar. Podemos representar uma função de quatro formas diferentes:\nVamos deixar os conceitos mais claros. Imagine que te propronho a seguinte regra: dividirei o número 2 por todos os números possíveis. Observe que, nesse exemplo, os números possíveis são todos exceto zero – afinal de contas, qualquer número dividido por zero resulta em uma indefinição matemática. Podemos dizer, portanto, que o domínio da nossa função é dado por todos os números reais exceto zero. Ao mesmo tempo, quais valores podem surgir como resultado dessa nossa regrinha? Novamente, todos os reais exceto zero – afinal, nenhum número que utilizemos será tão grande em valor absoluto tal que a divisão resulte em zero, ao passo que qualquer valor extremo (tanto negativo, quanto positivo) pode ser alcançado plugando na função valores menores do que um em módulo1! Portanto, nesse caso, a imagem da nossa função é idêntica ao domínio.\nPerceba que definimos a função acima de modo verbal, ou seja, com palavras. Poderíamos também descrevê-la numericamente através de uma tabela ou, então, de forma visual com um gráfico (ambas abaixo). De todo modo, a forma mais comum de se descrever uma função é através de sua fórmula que, no nosso exemplo, seria \\(f(x)=2/x\\).\nNão precisamos nos aprofundar nos conceitos. O que você precisa guardar dessa seção é o fato de podermos pensar na função como uma caixa preta que, ao receber elementos de \\(A\\), os transforma em um determinado valor (output) presente em \\(B\\). Como vimos, a forma pela qual essa ‘caixa preta’ irá transformar \\(x\\) em \\(f(x)\\) é a nossa regra propriamente dita.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Funções e pacotes</span>"
    ]
  },
  {
    "objectID": "funcoes-e-pacotes.html#o-que-é-uma-função",
    "href": "funcoes-e-pacotes.html#o-que-é-uma-função",
    "title": "3  Funções e pacotes",
    "section": "",
    "text": "Uma função é uma regra que atribui, para cada elemento \\(x\\) em um conjunto \\(A\\), exatamente um elemento, chamado \\(f(x)\\), em um conjunto \\(B\\).\n\n\n\nVerbalmente (através de palavras);\nNumericamente (através uma tabela de dados);\nVisualmente (através de um gráfico);\nAlgebricamente (através de uma fórmula)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(x\\)\n\\(f(x)\\)\n\n\n\n\n-3\n-0.67\n\n\n-2\n-1.00\n\n\n-1\n-2.00\n\n\n1\n2.00\n\n\n2\n1.00\n\n\n3\n0.67",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Funções e pacotes</span>"
    ]
  },
  {
    "objectID": "funcoes-e-pacotes.html#o-que-é-uma-função-para-o-r",
    "href": "funcoes-e-pacotes.html#o-que-é-uma-função-para-o-r",
    "title": "3  Funções e pacotes",
    "section": "3.2 O que é uma função para o R?",
    "text": "3.2 O que é uma função para o R?\nE por quê essa historinha toda sobre funções matemáticas nos interessa? Simplesmente pois podemos traçar um paralelo com o conceito de função para a linguagem R! No R, uma função é um objeto que recebe argumentos (inputs) e executa uma ação sobre ou a partir deles, de acordo com o bloco de código nela embutido, te devolvendo um determinado resultado (output). A lógica é a mesma de uma função matemática! O nome não é por acaso.\n\n\n\n\n\nflowchart LR\n  A(Input 1) --&gt; D[\"Caixa Preta \\n (Função)\"]\n  B(Input 2) --&gt; D[\"Caixa Preta \\n (Função)\"]\n  C(Input N) --&gt; D[\"Caixa Preta \\n (Função)\"]\n  D --&gt; E[Output]\n\n\n\n\n\n\nDe certa forma, continuamos a ter um domínio, pois cada função atende um número específico de estruturas de objeto e/ou tipos de variável – algumas funções podem aceitar apenas vetores como argumento, por exemplo, enquanto outras podem ser específicas para variavéis númericas. Ao mesmo tempo, continuamos a ter uma imagem, associada aos resultados possíveis. E qual é o equivalente à regra? É o bloco de código embutido na função!\n\n3.2.1 Vantagens\nNas seções anteriores, compreendemos um pouco melhor como funciona o mecanismo de uma função. Mas ainda pode haver dúvida do tipo: “Beleza, mas em qual contexto prático que ela será útil?”\nO grande benefício de uma função se constitui no fato de seu bloco de código interior, condicionado ao valor dos argumentos, realizar sempre a mesma tarefa quando a rodamos! Isso significa que as funções permitem automatizar tarefas comuns de uma forma mais legível, evitando a prática de ‘copiar e colar’ repetidamente as mesmas linhas de código, que serão substituídas pelo nome da função e seus argumentos. Na prática, além da melhor compreensão do código, eliminamos a chance de cometer erros bobos ao copiar e colar (por exemplo, acabar atualizando o nome de uma variável em um lugar, mas não em outro) e tornamos mais fácil reutilizar o trabalho que foi escrito em outros projetos, aumentando a produtividade.\n\n\n3.2.2 Criando\nA sintaxe para criar uma função é a seguinte:\n\nnome_da_funcao &lt;- function(arg1 = default1, ..., argn = defaultn) {\n  &gt;bloco de código&lt;\n}\n\nPerceba que o uso o operador &lt;- nos mostra que, ao criar uma função, estamos criando um objeto – que, nesse caso, não é designado especificamente a armazenar dados. Entre parentêses, definimos o nome dos argumentos e, caso necessário, seus respectivos valores de default. Na sequência, entre chaves, escrevemos o bloco de código que rodará sobre os inputs. Como exemplo, vamos criar a função soma2.\n\nsoma2 &lt;- function(somando1, somando2) {\n  (somando1 + somando2) ^ 2\n}\n\nO que ela faz? Soma dois números e eleva esse resultado intermediário ao quadrado. A função criada poderá ser vista no quadrante superior direito, no painel Environment.\n\n\n3.2.3 Utilizando\nPor sua vez, a sintaxe para usar uma função é:\n\nnome_da_funcao(arg1, ..., argn)\n\nEm primeiro lugar, é necessário escrever o nome da função no Editor de Código. Ao lado, entre parênteses, escreveremos seus argumentos – no exemplo acima, arg1, arg2 até argn; uma função pode ser construída de modo a ter qualquer número n de argumentos e eles serão sempre separados por vírgula. Esses argumentos são os nossos inputs. Por fim, rodamos a linha em que a escrevemos, fazendo com que seja executada pelo R e seu resultado apareça no Console.\n\n\n\n\n\n\nExemplo 1\n\n\n\nVamos tomar como exemplo a função sum(). O que ela faz? Segundo sua documentação:\n\nsum retorna a soma de todos os valores presentes em seus argumentos\n\nNa prática, como o nome já nos indica, ela tem como serventia somar todos os números que lhe forem passados. Se quisessemos utilizá-la para obter o resultado da soma dos números 4, 7 e 9, como faríamos? Se você pensou em sum(4, 7, 9), acertou!\n\nsum(4, 7, 9)\n\n[1] 20\n\n\nPerceba que utilizamos três argumentos, um para cada número que somamos: 4, 7 e 9 estão associados a arg1, arg2 e arg3, respectivamente. No entanto, dado que a função sum() aceita objetos como vetores, matrizes e dataframes, poderíamos ter utilizado apenas um único argumento!\n\nsum(c(4, 7, 9))\n\n[1] 20\n\nsum(matrix(c(4, 7, 9)))\n\n[1] 20\n\nsum(data.frame(c(4, 7, 9)))\n\n[1] 20\n\n\nNo chunk acima, c(4, 7, 9), matrix(c(4, 7, 9)) e data.frame(c(4, 7, 9)) estão associados apenas ao arg1! Em muitos casos, entender os tipos de objetos aceitos pela função será importante para a eficiência do código. Imagine que estivessemos com interesse de somar todos os valores de uma certa coluna em determinado dataframe. Como poderíamos realizar essa tarefa? Dado que cada coluna de um dataframe é simplesmente um vetor, poderíamos inserí-la diretamente na função, como um único argumento!\n\ndf1 = data.frame(x = c(4, 7, 9))\nsum(df1$x)\n\n[1] 20\n\n\nLembre-se de ficar atento com relação à estrutura e/ou tipo de variável que determinada função pode aceitar. Será que se trocassemos o número 4 por “4”, a função ainda rodaria? A respota é não, afinal de contas “4” é interpretado como texto, e não como número (e você não consegue somar textos)!\n\nsum(c(\"4\", 7, 9))\nError in sum(df1$x) : 'type' inválido (character) do argumento\n\n\n\nEm muitas situações, teremos argumentos nomeados. Isto ocorre pois nem todo argumento será processado da mesma forma pelo código embutido na função. Também é muito comum que certos argumentos tenham um valor pré-determinado como default, isto é, caso você não especifique algum valor para aquele argumento, o valor de default será utilizado.\n\n\n\n\n\n\nExemplo 2\n\n\n\nNesse caso, vamos tomar como exemplo a função paste(). Qual seu papel?\n\nConcatenar vetores após converter em caractere\n\nPortanto, a função paste irá transformar os vetores que introduzirmos em vetores com dados do tipo character e, na sequência, irá juntá-los. Na prática, serve para juntar palavras e/ou caracteres que estão inicialmente separados em uma única variável do tipo texto. Por exemplo, podemos estar dispostos a juntar as palavras “Estou”, “apredendendo” e “a usar o R” em um único vetor.\n\npaste(\"Estou\", \"aprendendo\", \"a usar o R\")\n\n[1] \"Estou aprendendo a usar o R\"\n\n\nNote que o caractere default (padrão) utilizado para separar as palavras é o espaço em branco! E se quisessemos separá-las por vírgula? Nesse caso, teríamos que especificar o argumento sep com esse delimitador!\n\npaste(\"Estou\", \"aprendendo\", \"a usar o R\", sep = \",\")\n\n[1] \"Estou,aprendendo,a usar o R\"\n\n\n\n\nPor fim note que, mesmo sem você saber, já utilizamos funções nos últimos capítulos!\n\nc(): função utilizada para criar um vetor;\nmatrix(): para criar uma matriz;\ndata.frame(): para criar um data frame;\nlist(): para criar uma lista.\n\nTodas essas funções utilizavam como argumento principal os dados que tínhamos interesse e, através de seu código embutido, criavam e armazenavam o objeto na memória do R!\n\n\n\n\n\n\nOperadores são funções! (Opcional)\n\n\n\n\n\nSim, é isso mesmo que você leu! Lembre-se das nossas máximas: tudo que existe no R é um objeto e tudo que acontece é uma execução de função. É algo simples e direto ver que operadores como + , : e &lt;- existem na linguagem – não à toa estão sendo mencionados. Mas perceba que eles também criam, armazenam ou transformam objetos! Por exemplo, o operador + transforma 1+1 em 2! Pense nos operadores como um tipo especial de função de dois argumentos, o primeiro posicionado à esquerda e o segundo à direita.\n“Mas uma função não deveria ser escrita como nome_da_funcao(arg1, ..., argn)?“ Você pode escrevê-los dessa forma também! Só não será tão útil.\n\n`+`(1, 3)     # O mesmo que 1 + 3\n\n[1] 4\n\n`:`(1, 10)    # 1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n`&lt;-`(x, 10)   # x &lt;- 10\n\n\n\n\n\n\n\n\n\n\nFunções no Excel (Opcional)\n\n\n\n\n\nSe você já usou o Microsoft Excel em algum momento da sua vida, com certeza já teve contato com o alguma função! Por exemplo, lá temos a função =SOMA(), que realiza a mesma tarefa da função sum() no R! Inclusive, também é possível criar funções no Excel através de sua linguagem de programação própria, o Visual Basic for Applications (VBA).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Funções e pacotes</span>"
    ]
  },
  {
    "objectID": "funcoes-e-pacotes.html#pacotes",
    "href": "funcoes-e-pacotes.html#pacotes",
    "title": "3  Funções e pacotes",
    "section": "3.3 Pacotes",
    "text": "3.3 Pacotes\nChamamos de pacote um conjunto de dados e/ou funções, acompanhadas de suas respectivas documentações, que foram criadas e disponibilizadas por alguma pessoa. Existem pacotes padrão (ou básicos) que são considerados parte do código-fonte do R e estão automaticamente disponíveis como parte da instalação do R (ou seja, foram criados pelos desenvolvedores da linguagem). No entanto, definitivamente não são a maioria: o grosso dos pacotes disponíveis é de autoria dos membros da comunidade. Normalmente, as funções que integram um pacote estão relacionadas à determinado tema, ainda que isso não seja obrigatório.\nPor exemplo, suponha que criemos quatro funções que antes não existiam na linguagem: soma(), subtração(), multiplicacao() e divisao(), representando as quatro operações aritméticas básicas. Como estão relacionadas à um mesmo tema, poderiamos agrupá-las em um pacote chamado aritmetica e, na sequência, disponibilizá-lo em algum repositório para que outros usuários da linguagem pudessem baixá-lo. As pessoas que instalassem e carregassem nosso pacote teriam acesso às quatro funções acima, sem necessidade de ter que criá-las do zero! Ao mesmo tempo, o autor poderia adicionar um dataframe ao pacote, com intuito de possibilitar que você teste as funções que ele criou2.\nPerceba que, quando alguém cria uma função ou disponibiliza dados através de um pacote, fica complicado compreender inicialmente todas as características que esses objetos possuem. Por exemplo: ainda que os nomes sejam sugestivos, você saberia dizer com precisão o comportamento das quatro funções do pacote que criamos? Quais os tipos de objeto e variável que elas aceitam? Quais e quantos argumentos cada uma aceita? Provavelmente não. Para responder à todas essas perguntas, os autores disponibilizam uma documentação para cada objeto do pacote! Para acessá-la, basta rodar o nome da função/conjunto de dados acrescido de ? no início. O texto irá aparecer no quadrante inferior direito do RStudio, no painel Help3.\n\n3.3.1 Instalando\nA maneira mais comum de se baixar e instalar um pacote é através do CRAN! O mesmo local em que baixamos o R também atua como um repositório centralizado de pacotes. Mas fique tranquilo: você não precisará acessar o site novamente! Para baixar e instalar um pacote que está no CRAN, utilizaremos a função install.packages(), pertencente ao pacote utils (que é um pacote básico). Basta rodar install.packages(\"nome_do_pacote\"). No exemplo abaixo, a instalação do pacote readr.\n\ninstall.packages(\"readr\")\n\nRealizada a instalação com sucesso, já passa a ser possível utilizar suas funções/dados. Nesse momento, você deverá escrever o nome do pacote acrescido de :: e, na sequência, o nome da função/dado.\n\nreadr::read_csv(...)\n\n\n\n3.3.2 Carregando\n“Mas será sempre necessário escrever o nome do pacote antes da função?” Não. Perceba que os objetos oriundos de pacotes básicos podem ser executados diretamente. Isso ocorre pois eles são automaticamente carregados na sua sessão atual.\nResumindo: mesmo que você tenha instalado um pacote externo com sucesso, para usar seus objetos diretamente (sem precisar escrever seu nome antes) é necessário carregá-lo na sessão atual. Para carregar um pacote, rode a função library() acrescida do nome do pacote, sem aspas.\n\nlibrary(readr)\n\nAgora, é possível executar o objeto sem precisar escrever o nome do pacote antes.\n\nread_csv(...)\n\nA prática de carregar pacotes é a mais utilizada. Em outras palavras: sempre que instalarmos algum pacote, na sequência iremos carregá-lo na sessão atual para que possamos utilizar seus objetos de forma direta.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Funções e pacotes</span>"
    ]
  },
  {
    "objectID": "funcoes-e-pacotes.html#operador-pipe",
    "href": "funcoes-e-pacotes.html#operador-pipe",
    "title": "3  Funções e pacotes",
    "section": "3.4 Operador Pipe %>%",
    "text": "3.4 Operador Pipe %&gt;%\nNem sempre conseguiremos atingir o resultado que queremos utilizando apenas uma função. Por esse motivo, em muitas situações utilizaremos o resultado de uma função como argumento de outra função.\nPor exemplo, suponha que você queira somar dois números e, na sequência, comparar este resultado intermediário com 5 e 9, de modo a retornar o valor máximo entre os três números. Observe que a função sum() não é suficiente para realizar tal tarefa de modo completo: você até conseguirá somar dois números quaisquer, mas não será capaz de posteriormente comparar o resultado com o restante para saber qual é o valor máximo entre eles. Nesse caso, poderíamos então utilizar o resultado da função sum() como argumento da função max()!\n\nmax(sum(4, 3), 5, 9)\n\n[1] 9\n\n\nO R sempre executará as funções interiores primeiro. Ou seja, primeiro executa sum(4,3), retornando 7, e na sequência executa max(7, 5, 9), cujo resultado será 9, dado que este é o maior dentre os três números utilizados como argumento.\nO problema com esse tipo de sintaxe é que, conforme aproveitamos os resultados anteriores de outra função como argumento para as seguintes, mais confuso o código fica. Imagine se o número 4 também fosse resultado de alguma outra função: o código estaria bem mais difícil de entender!\n\nmax(sum(outra_funcao(...), 3), 5, 9)\n\nCom a finalidade de simplificar situações desse tipo, criou-se o operador Pipe, representado por %&gt;%. Este operador permite com que o resultado da função anterior se torne, implicitamente, o primeiro argumento da função seguinte! Poderíamos então reescrever nosso exemplo para:\n\nsum(4,3) %&gt;% max(5, 9)\n\n[1] 9\n\n\nO que o código acima nos diz é que sum(4,3) será interpretado como o primeiro argumento da função max(); automaticamente, 5 e 9 se tornam o segundo e o terceiro argumentos, respectivamente.\nPara utilizar o operador Pipe, antes é necessário instalar e carregar o pacote magrittr:\n\ninstall.packages(\"magrittr\")\nlibrary(magrittr)\n\nNa sequência, aperte Ctrl + Shift + M no Editor ou Console.\n\n3.4.1 Pipe nativo\nO uso do operador Pipe se tornou tão poopular que os desenvolvedores do R resolveram incorporar uma versão própria que já vem pré-instalada, conhecida como Pipe nativo (native Pipe). Ele exerce o mesmo papel principal (organização de código, como demonstrado na seção anterior) mas deixa a desejar em outras partes. A única vantagem é não precisar instalar e carregar um pacote. Portanto, recomendamos ainda o uso do Pipe ‘original’.\nDe todo modo, caso você queira utilizá-lo, basta substituir %&gt;% por |&gt;. Para continuar usando o atalho Ctrl + Shift + M, vá em Tools &gt; Global Options &gt; Code e marque Use native pipe operator.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Funções e pacotes</span>"
    ]
  },
  {
    "objectID": "funcoes-e-pacotes.html#footnotes",
    "href": "funcoes-e-pacotes.html#footnotes",
    "title": "3  Funções e pacotes",
    "section": "",
    "text": "Pense em números como \\(0,01\\), por exemplo. Inserindo na nossa função, teríamos então \\(f(x)=2/0,01=200\\). Se inseríssemos \\(0,001\\), obteríamos \\(f(x)=2/0,001=2000\\). O mesmo vale para valores negativos, apenas alterando o sinal do resultado. Perceba que, sendo em módulo menor do que um, quanto mais próximo de zero for o número, mais extremo será o resultado da função.↩︎\nOutra possibilidade seria adicionar um dataframe simplesmente pelo interesse em utilizar as informações que podem estar contidas nele. Por exemplo, existem pacotes que contém apenas dataframes com informações de tabelas de livros-texto específicos; com isso, os usuários ganham o poder de replicar os resultados encontrados pelo autor, facilitando o aprendizado. É importante ressaltar, contudo, que pacotes normalmente são compostos apenas por funções.↩︎\nAs documentações sempre aparecerão escritas em inglês.↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Funções e pacotes</span>"
    ]
  }
]